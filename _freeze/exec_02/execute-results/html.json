{
  "hash": "890f3df26b2168a982c97e49682707c2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R과 데이터사이언스: 개요\"\nauthor: 이상일(서울대학교 지리교육과)\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\nbibliography: references.bib\n---\n\n\n## 실습 개요 {.unnumbered}\n\n이 실습은 R로 데이터사이언스를 하는 과정을 개괄적으로 이해하기 위한 것이다. 특히 @fig-R_DS-process2 에 나타나 있는 데이터사이언스 과정 중 특히 네 부분, 데이터 불러오기(importing), 정리하기(tidying), 변형하기(transforming), 시각화하기(visualizing)에 초첨을 맞춘다. 보통 데이터 정리하기와 변형하기를 합쳐 데이터와 씨름하기(wrangling)이라고 부르고, 정리하기와 시각화하기를 합쳐 탐색하기(exploring)라고 한다. 데이터를 살펴보기 위해 모델링을 사용하는 경우, 일부 모델링하기도 탐색하기에 포함되는 것으로 볼 수도 있다.\n\n![데이터사이언스의 과정(<https://r4ds.hadley.nz/whole-game>)](https://r4ds.hadley.nz/diagrams/data-science/whole-game.png){#fig-R_DS-process2}\n\n데이터사이언스의 다양한 과업을 수행하기 위해 Base R의 함수들이 사용되고 있지만, 보통은 이와 함께 다양한 패키지(package)들이 널리 사용되고 있다. 따라서 본 실습에서는 우선 패키지의 사용과 관련된 부분을 다루고 뒤를 이어 데이터사이언스의 네 과제가 어떻게 이루어지는지 대략적으로 다룰 것이다.\n\n1.  패키지와 tidyverse\n2.  데이터 시각화하기\n3.  데이터 변형하기\n4.  데이터 정리하기\n5.  데이터 불러오기\n\n## 패키지와 tidyverse 패키지\n\n### 패키지\n\n패키지는 유사한 과업을 수행하는데 도움을 주는 함수들의 묶음 정도로 정의할 수 있다. 현재 [CRAN(The Comprehensive R Archive Network)](https://cran.rstudio.com/)에는 20,000개 정도의 패키지가 등록되어 있다고 한다. CRAN에 패키지를 등록하는게 쉽지 않은 일이기 때문에 GitHub과 같은 곳을 통해 접근 가능한 패키지까지 합치면 도채체 몇 개의 R 패키지가 세상에 존재하는지 알기 어렵다.\n\n패키지를 사용하기 우선 패키지가 사용자의 디바이스에 물리적으로 인스톨되어 있어야 하고, R 세션에서 패키지를 불러와야 한다. 패키지를 인스톨하는 방법은 두 가지 이다. 스크립트 내에서 패키지를 반복해서 인스톨하는 것은 합리적이지 않기 때문에 전자의 관행을 추천한다.\n\n-   Output 창의 Packages 탭 선택: Install 아이콘 클릭하고 패키지 이름 입력\n\n-   스크립트 내에서 인스톨하기: `install.packages(\"패키지명\")`\n\n쌍따옴표 속에 패키지 이름을 타이핑해야 한다. 한번 인스톨이 되면 업데이트하지 않는 한 새롭게 패키지를 인스톨할 필요가 없다. 인스톨된 패키지를 사용하려면 스크립트 내에서 다음과 같이 타이핑하고 실행한다.\n\n-   `library(패키지명)`\n\n괄호 속에 패키지명을 기입해야 한다.\n\n::: callout-important\n`install.packages()`함수에서는 반드시 패키지명을 쌍따옴표로 싸야하지만, `library()`함수에서는 그렇지 않다. 불러온 패키지는 R 세션이 유지되는 동안 내내 사용할 수 있지만, R 세션을 끝내고 다시 시작하면 다시 `library()`함수를 이용해 다시 불러와야 한다. 그래서 R 스크립트 파일의 시작 부분에는 패키지를 불러오는 코드를 위치시키고, 다시 스크립트 파일을 열 때마다 그 부분을 재실행하는 것이 좋은 습관이다.\n:::\n\n### `tidyverse` 패키지\n\n데이터사이언스 과정의 각 단계는 특징적인 과업으로 구성되어 있고, 거기에 맞춰 특징적인 함수들을 장착한 패키지들이 개발되어 왔다. 그런데 최근 RStudio는 데이터사이언스와 밀접히 관련된 패키지들을 모아 일종의 엄브렐러 패키지인 [`tidyverse`](https://www.tidyverse.org/)를 만들어 제공하고 있다. [`tidyverse`](https://www.tidyverse.org/) 패키지는 패키지의 패키지인데, 핵심적인 구성 패키지에 다음과 같은 것들이 있다.\n\n-   [`ggplot2`](https://ggplot2.tidyverse.org/): 시각화하기\n\n-   [`dplyr`](https://dplyr.tidyverse.org/): 변형하기\n\n-   [`tidyr`](https://tidyr.tidyverse.org/):정리하기\n\n-   [`readr`](https://readr.tidyverse.org/): 불러오기\n\n-   [`tibble`](https://tibble.tidyverse.org/): 데이터 프레임 관련\n\n-   [`stringr`](https://stringr.tidyverse.org/): 문자열 처리 관련\n\n-   [`forcats`](https://forcats.tidyverse.org/): 범주 변수(팩터) 처리 관련\n\n-   [`lubracate`](https://lubridate.tidyverse.org/): 시간 변수 처리 관련\n\n-   [`purrr`](https://purrr.tidyverse.org/): 함수형 프로그래밍(functional programming) 관련\n\n[`tidyverse`](https://www.tidyverse.org/) 패키지를 사용하는 것의 장점은 이 패키지만 불러오면 구성 패키지까지 한꺼번에 사용할 수 있게 된다는 점이다. 스크립트 내에서 다음과 같은 코드를 실행한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## 시각화하기\n\n### 데이터 살펴보기\n\n이 실습을 위해 남극 파머군도(Palmer Archipelago)에 서식하는 펭귄 성체의 신체 계측 데이터를 사용한다. 이 데이터는 [`palmerpenguins`](https://allisonhorst.github.io/palmerpenguins/)라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\n```\n:::\n\n\n이제 이 페키지에 포함되어 있는 `penguins`라는 이름의 데이터를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n데이터를 자세히 살펴보면 몇 가지를 알 수 있다.\n\n-   티블(`tibble`)이라는 형식의 데이터 프레임이다. 티블은 [`tidyverse`](https://www.tidyverse.org/)의 공식 데이터 프레임 포맷이다.\n\n-   관측개체는 344개, 변수는 8개이다.\n\n-   `species`, `island`, `sex` 변수의 유형은 팩트형(`fctr`)이고, `bill_length_mm`, `bill_depth_mm`은 실수형(`dbl`)이고, 나머지는 정수형(`int`)이다.\n\n변수가 많아지면 전체 데이터를 조망하기 어렵기 때문에, 최초의 [`tidyverse`](https://www.tidyverse.org/) 함수인 `glimpse()`를 사용하여 데이터의 행과 열을 바꾸어 보자.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n```\n\n\n:::\n:::\n\n\n### 그래프 만들기\n\n이 `penguins` 데이터와 `ggplot2()` 패키지를 이용하여 \"펭귄의 날개 길이와 몸무게의 관계\"를 표현하는 그래프를 작성해 보자. `ggplot2()`의 문법에 대한 사항은 따로 공부할 기회가 있으므로 여기서는 제작 과정을 한 번 따라가 본다.\n\n#### 플롯 객체의 지정\n\n`ggplot()`이라는 함수를 통해 플롯 제작을 개시하는 단계이며, 어떤 데이터를 사용할지를 지정한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins)\n```\n\n::: {.cell-output-display}\n![](exec_02_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n#### 플롯의 심미성 지정\n\n데이터가 어떤 시각적 속성으로 표현될 것인가를 지정한다. 여기서는 간단히 어떤 변수들이 x-축과 y-축에 나타나는지만 지정한다. `mapping = aes()` 아규먼트가 핵심이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n```\n\n::: {.cell-output-display}\n![](exec_02_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n#### 플롯의 기하 속성 지정\n\n데이터가 어떤 기하학적 속성으로 표현될 것인가를 지정한다. `geom` 아규먼트가 핵심인데, `geom_point()`는 데이터를 포인트라고 하는 기하학적 속성으로 표현한다는 것을 지정한 것으로 결국 산포도(scatterplot)을 산출하게 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](exec_02_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n#### 심미성의 첨가\n\n이러한 관련성이 펭귄의 종족에 따라 다르게 나타나는지를 탐색하기 위해 `color` 라는 심미성을 `species`라는 변수에 적용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](exec_02_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n#### 기하 레이어의 첨가\n\n두 변수의 관련성을 보여주는 선형 기하를 첨가한다. 여기서는 `geom_smooth()`를 이용하여 OLS 회귀선을 첨가한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n```\n\n::: {.cell-output-display}\n![](exec_02_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n#### 라벨링 등 마무리 작업\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Body mass and flipper length\",\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n    color = \"Species\", shape = \"Species\"\n  )\n```\n\n::: {.cell-output-display}\n![](exec_02_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n## 변형하기\n\n변형하기와 관련된 함수들은 대부분 [`dplyr`](https://dplyr.tidyverse.org/) 패키지에 포함되어 있다.\n\n### 데이터 살펴보기\n\n이 실습을 위해 미국 교통통계국(U.S. Bureau of Transportation)이 제공하는 데이터를 사용하는데, 이것은 2013년 한 해 동안 미국 뉴욕시를 출발한 336,776대의 항공기에 대한 정보를 담고 있다. 이 데이터는 [`nycflights13`](https://github.com/tidyverse/nycflights13) 이라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다. 그리고 나서 패키지에 포함되어 있는 `flights`라는 이름의 데이터를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights13)\nglimpse(flights)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 336,776\nColumns: 19\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n```\n\n\n:::\n:::\n\n\n### 주요 함수\n\n여기서는 가장 널리 사용되는 6개 함수에 대해서만 개략적으로 다룬다. 그 6개 함수는 `select()`, `filter()`, `arrange()`, `mutate()`, `group_by()`, `summerize()`이다. 조교의 도움을 받아 각 함수가 무슨 일을 한 것인지 이해한다.\n\n#### `select()` 함수\n\n열(변수) 중 일부를 솎아낸다. 즉, 변수의 갯수를 줄인다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(flights, year, month, day)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 3\n    year month   day\n   <int> <int> <int>\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n#### `filter()` 함수\n\n특정 열(변수)에 의거해 조건을 만족하는 행을 솎아낸다. 즉 관측개체의 갯수를 줄인다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(flights, month == 1 & day == 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n#### `arrange()` 함수\n\n특정 열(변수)에 의거해 행의 순서를 바꾼다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(flights, year, month, day)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n#### `mutate()` 함수\n\n기존의 열(변수)을 변형하여 새로운 열(변수)을 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(flights,\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 21\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>, gain <dbl>, speed <dbl>\n```\n\n\n:::\n:::\n\n\n#### `group_by()` 함수\n\n열(변수)(범주형 변수, categorical variables)에 의거해 전체 행을 그룹으로 분할한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_by(flights, month)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n#### `summerize()` 함수\n\n열(변수)의 통계량을 산출하여 새로운 열(변수)에 저장한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  delay\n  <dbl>\n1  12.6\n```\n\n\n:::\n:::\n\n\n위의 `group_by()` 함수와 결합하면, 그룹별로 열(변수)의 통계량을 산출하여 새로운 열(변수)에 저장할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_day <- group_by(flights, year, month, day)\nsummarize(by_day, delay = mean(dep_delay, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day delay\n   <int> <int> <int> <dbl>\n 1  2013     1     1 11.5 \n 2  2013     1     2 13.9 \n 3  2013     1     3 11.0 \n 4  2013     1     4  8.95\n 5  2013     1     5  5.73\n 6  2013     1     6  7.15\n 7  2013     1     7  5.42\n 8  2013     1     8  2.55\n 9  2013     1     9  2.28\n10  2013     1    10  2.84\n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n\n## 정리하기\n\n정리하기와 관련된 함수들은 대부분 [`tidyr`](https://tidyr.tidyverse.org/) 패키지에 포함되어 있다. 많은 함수가 있지만 가장 중요한 두 개의 함수에만 집중한다.\n\n### 데이터 살펴보기\n\n이 실습에서는 `tidyverse`에 포함되어 있는 매우 단순한 데이터를 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable4a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n\n\n:::\n:::\n\n\n### 주요 함수\n\n#### `pivot_longer()` 함수\n\n`table4a`에서 1999과 2000은 변수명일 수 없다. `year`라는 변수의 속성이어야 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_longer(\n  table4a, \n  cols = c(`1999`, `2000`),\n  names_to = \"year\",\n  values_to = \"cases\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  country     year   cases\n  <chr>       <chr>  <dbl>\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n```\n\n\n:::\n:::\n\n\n#### `pivot_wider()` 함수\n\n`table2`에서 `type` 변수는 두 개의 변수명을 포함하고 있다. 즉, `cases`와 `population`은 속성값이라기 보다는 변수명이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_wider(\n  table2, \n  names_from = \"type\",\n  values_from = \"count\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n\n\n:::\n:::\n\n\n## 불러오기\n\n불러오기와 관련된 함수들은 대부분 [`readr`](https://readr.tidyverse.org/) 패키지에 포함되어 있다. 여러 유형의 파일을 불러오기 위해 여러 함수가 존재하지만, 콤마분리값(comma-separated values, CSV) 형식의 데이터를 불러오는 함수(`read_csv()`)만 실습한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudents <- read_csv(\"https://pos.it/r4ds-students-csv\")\nglimpse(students)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 6\nColumns: 5\n$ `Student ID`   <dbl> 1, 2, 3, 4, 5, 6\n$ `Full Name`    <chr> \"Sunil Huffmann\", \"Barclay Lynn\", \"Jayendra Lyne\", \"Leo…\n$ favourite.food <chr> \"Strawberry yoghurt\", \"French fries\", \"N/A\", \"Anchovies…\n$ mealPlan       <chr> \"Lunch only\", \"Lunch only\", \"Breakfast and lunch\", \"Lun…\n$ AGE            <chr> \"4\", \"5\", \"7\", NA, \"five\", \"6\"\n```\n\n\n:::\n:::\n\n\n## 파이프 연산자(pipe operator)\n\n우리는 이전 실습에서 할당 연산자(`<-`)에 대해 배웠다. 오늘 살펴본 다양한 변형의 결과를 다른 데이터 프레임에 담고 싶으면 다음과 같이 할당 연산자를 사용할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_day1 <- filter(flights, month == 1 & day == 1)\nglimpse(flights_day1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 842\nColumns: 19\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n```\n\n\n:::\n:::\n\n\n앞으로 할당 연산자보다 훨씬 더 빈번하게 사용하게 될 연산자를 소개하려고 한다. 그것은 파이프 연산자(pipe operator)라는 것으로, `%>%` 혹은 `|>`로 표시하는 것이다. 원래 이 연산자의 원리는 [`magrittr`](https://magrittr.tidyverse.org/) 패키지에서 처음 소개되었는데, 차츰 R 커뮤니티에 파급되더니 급기야는 대세로 자리잡았다. 그래서 특정 패키지를 깔지 않아도 파이프 연산자를 사용할 수 있게 하기 위해 Base R에 도입되었고(이것을 원파이프 연산자(native pipe operator)라고 부른다), 부호로 `%>%` 대신 `|>`를 사용한다. 둘 사이에 차이는 거의 없지만, 후자가 점점 표준이 되고 있기 때문에 본 수업에서는 그것을 사용한다. 다음의 두 가지에 유의한다.\n\n-   현재 RStudio의 디폴트는 `%>%`로 설정되어 있다. 이것을 Tools \\> Global Options \\> Code에 가서 'Use native pipe operator, \\|\\> (requires R 4.1+)'를 선택해 주어야 한다. 아래의 @fig-pipe-operator 를 참고하라.\n\n![파이프 연산자(https://r4ds.hadley.nz/data-transform)](https://r4ds.hadley.nz/screenshots/rstudio-pipe-options.png){#fig-pipe-operator}\n\n-   단축키는 Crtl + Shift + M이다. 다른 건 몰라도 이 단축키만은 반드시 기억해야 한다.\n\n다음의 두 코드를 비교해 보라. 먼저 파이프 연산자를 사용하지 않은 경우이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights1 <- filter(flights, dest == \"IAH\")\nflights2 <- mutate(flights1, speed = distance / air_time * 60)\nflights3 <- select(flights2, year:day, dep_time, carrier, flight, speed)\narrange(flights3, desc(speed))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   <int> <int> <int>    <int> <chr>    <int> <dbl>\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n```\n\n\n:::\n:::\n\n\n다음은 파이프 연산자를 사용한 경우이다. 동일한 결과를 가져다 주지만 훨신 더 간결하고 직관적이고 이해하기 쉽다. 파이프 연산자의 사용 원리는 뒤에서 자세히 배운다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(dest == \"IAH\") |> \n  mutate(speed = distance / air_time * 60) |> \n  select(year:day, dep_time, carrier, flight, speed) |> \n  arrange(desc(speed))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   <int> <int> <int>    <int> <chr>    <int> <dbl>\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n```\n\n\n:::\n:::\n\n\n## \n",
    "supporting": [
      "exec_02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}