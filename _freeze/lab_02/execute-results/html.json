{
  "hash": "ed939a4f56a2eb811d83c36c79d0d4e0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lab02: R과 데이터사이언스\"\nauthor: 이상일(서울대학교 지리교육과 교수), 김세창(사회교육과 지리전공 석사), 김우형(사회교육과 지리전공 석사과정)\nnumber-sections: true\nformat: \n  html: \n    toc: true\n    embed-resources: true\ncode-link: true\ncode-copy: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\n---\n\n\n## 실습의 목표 {.unnumbered}\n\n1.  **R의 패키지**에 대해 이해할 수 있다.\n\n2.  **데이터사이언스의 과정**을 개괄적으로 이해할 수 있다.\n\n    -   데이터 시각화하기\n\n    -   데이터 변형하기\n\n    -   데이터 정리하기\n\n    -   데이터 불러오기\n\n3.  **파이프 연산자**의 사용법에 대해 이해할 수 있다.\n\n## 패키지\n\n패키지를 사용하기 우선 패키지가 사용자의 디바이스에 물리적으로 인스톨되어 있어야 하고, R 세션에서 패키지를 불러와야 한다. 패키지를 인스톨하는 방법은 두 가지 이다. 스크립트 내에서 패키지를 반복해서 인스톨하는 것은 합리적이지 않기 때문에 전자의 관행을 추천한다.\n\n-   Output 창의 Packages 탭 선택: Install 아이콘 클릭하고 패키지 이름 입력\n\n-   스크립트 내에서 인스톨하기: `install.packages(\"패키지명\")`\n\n쌍따옴표 속에 패키지 이름을 타이핑해야 한다. 한번 인스톨이 되면 업데이트하지 않는 한 새롭게 패키지를 인스톨할 필요가 없다. 인스톨된 패키지를 사용하려면 스크립트 내에서 다음과 같이 타이핑하고 실행한다.\n\n-   `library(패키지명)`\n\n괄호 속에 패키지명을 기입해야 한다.\n\n::: callout-important\n`install.packages()`함수에서는 반드시 패키지명을 쌍따옴표로 싸야하지만, `library()`함수에서는 그렇지 않다. 불러온 패키지는 R 세션이 유지되는 동안 내내 사용할 수 있지만, R 세션을 끝내고 다시 시작하면 다시 `library()`함수를 이용해 다시 불러와야 한다. 그래서 R 스크립트 파일의 시작 부분에는 패키지를 불러오는 코드를 위치시키고, 다시 스크립트 파일을 열 때마다 그 부분을 재실행하는 것이 좋은 습관이다.\n:::\n\n[`tidyverse`](https://www.tidyverse.org/) 패키지를 사용하는 것의 장점은 이 패키지만 불러오면 구성 패키지까지 한꺼번에 사용할 수 있게 된다는 점이다. 스크립트 내에서 다음과 같은 코드를 실행한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## 시각화하기\n\n### 데이터 살펴보기\n\n이 실습을 위해 남극 파머군도(Palmer Archipelago)에 서식하는 펭귄 성체의 신체 계측 데이터를 사용한다. 이 데이터는 [`palmerpenguins`](https://allisonhorst.github.io/palmerpenguins/)라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\n```\n:::\n\n\n이제 이 패키지에 포함되어 있는 `penguins`라는 이름의 데이터를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\n데이터를 자세히 살펴보면 몇 가지를 알 수 있다.\n\n-   티블(`tibble`)이라는 형식의 데이터 프레임이다. 티블은 [`tidyverse`](https://www.tidyverse.org/)의 공식 데이터 프레임 포맷이다.\n\n-   관측개체는 344개, 변수는 8개이다.\n\n-   `species`, `island`, `sex` 변수의 유형은 팩트형(`fctr`)이고, `bill_length_mm`, `bill_depth_mm`은 실수형(`dbl`)이고, 나머지는 정수형(`int`)이다.\n\n변수가 많아지면 전체 데이터를 조망하기 어렵기 때문에, 최초의 [`tidyverse`](https://www.tidyverse.org/) 함수인 `glimpse()`를 사용하여 데이터의 행과 열을 바꾸어 보자.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## 데이터 내 속성들에 대한 정보가 궁금할 때\n\n`penguins` 데이터 내 속성들에 대한 설명을 보고싶다면 `help(penguins)` 또는 `?penguins`를 입력한 뒤 실행한다. ![penguins 데이터에 대한 설명](image/help.png)\n:::\n\n### 그래프 만들기\n\n이 `penguins` 데이터와 `ggplot2()` 패키지를 이용하여 \"펭귄의 날개 길이와 몸무게의 관계\"를 표현하는 그래프를 작성해 보자. `ggplot2()`의 더 많은 사용법에 대해서는 이후의 실습에서 매우 자세히 다룰 것이기 때문에 오늘은 간단한 제작 과정만을 따라가 보면서 데이터 시각화에 흥미를 가질 수 있도록 해보자.\n\n#### 플롯 객체의 지정\n\n`ggplot()`이라는 함수를 통해 플롯 제작을 개시하는 단계이며, 어떤 데이터를 사용할지를 지정한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = penguins) # 플롯 제작에 penguins 데이터를 사용\n```\n\n::: {.cell-output-display}\n![](lab_02_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n#### 플롯의 심미성 지정\n\n데이터가 어떤 시각적 속성으로 표현될 것인가를 지정한다. 여기서는 간단히 어떤 변수들이 x-축과 y-축에 나타나는지만 지정한다. `mapping = aes()` 아규먼트가 핵심이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g) # x축에 날개 길이, y축에 몸무게를 표시\n)\n```\n\n::: {.cell-output-display}\n![](lab_02_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n::: callout-tip\n## 코드의 가독성을 위한 Tip\n\nR에서 코드를 작성하다 보면 한 덩어리의 코드가 매우 길어지는 일이 빈번하게 발생한다. 코드를 정리하지 않고 계속 작성할 경우 작성자 본인이 봐도 무엇을 한 것인지 모르는 일이 발생하기 때문에 줄바꿈을 통해 코드를 간결하게 정리하는 것이 좋다. 특히 R이 익숙하지 않은 초보자의 경우 각 줄마다 본인이 무엇을 했는지 \\# 각주를 통해 설명을 달아 놓으면 R 문법에 익숙해지는데 도움이 된다.\n:::\n\n#### 플롯의 기하 속성 지정\n\n데이터가 어떤 기하학적 속성으로 표현될 것인가를 지정한다. `geom` 아규먼트가 핵심인데, `geom_point()`는 데이터를 포인트라고 하는 기하학적 속성으로 표현한다는 것을 지정한 것으로 결국 산포도(scatterplot)을 산출하게 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = penguins, # 플롯 제작에 penguins 데이터를 사용\n  mapping = aes(x = flipper_length_mm, y = body_mass_g) # x축에 날개 길이, y축에 몸무게를 표시\n) +\n  geom_point() # 데이터를 산포도로 표현\n```\n\n::: {.cell-output-display}\n![](lab_02_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n#### 심미성의 첨가\n\n이러한 관련성이 펭귄의 종족에 따라 다르게 나타나는지를 탐색하기 위해 `color` 라는 심미성을 `species`라는 변수에 적용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = penguins, # 플롯 제작에 penguins 데이터를 사용\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species) # x축에 날개 길이, y축에 몸무게를 표시, 종별로 색상을 지정\n) +\n  geom_point() # 데이터를 산포도로 표현\n```\n\n::: {.cell-output-display}\n![](lab_02_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n#### 기하 레이어의 첨가\n\n두 변수의 관련성을 보여주는 선형 기하를 첨가한다. 여기서는 `geom_smooth()`를 이용하여 OLS 회귀선을 첨가한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = penguins, # 플롯 제작에 penguins 데이터를 사용\n  mapping = aes(x = flipper_length_mm, y = body_mass_g) # x축에 날개 길이, y축에 몸무게를 표시\n) +\n  geom_point(mapping = aes(color = species)) + # 데이터를 산포도로 표현, 종별로 색상을 지정\n  geom_smooth(method = \"lm\") # OLS 회귀선을 추가\n```\n\n::: {.cell-output-display}\n![](lab_02_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## OLS 회귀선이란?\n\nOLS(Ordinary Least Square, 최소제곱법) 회귀선이란 관측값과 회귀선의 차이인 잔차의 제곱을 최소화하는 직선을 의미한다. 데이터들의 추세선 정도로 이해하면 된다. 선 주변의 음영은 신뢰 구간을 나타내는데, 이를 제거하고 싶으면 `se = FALSE`를 추가하면 된다.\n:::\n\n#### 라벨링 등 마무리 작업\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = penguins, # 플롯 제작에 penguins 데이터를 사용\n  mapping = aes(x = flipper_length_mm, y = body_mass_g) # x축에 날개 길이, y축에 몸무게를 표시\n) +\n  geom_point(mapping = aes(color = species)) + # 데이터를 산포도로 표현, 종별로 색상을 지정\n  geom_smooth(method = \"lm\") + # OLS 회귀선을 추가\n  labs(\n    title = \"Body mass and flipper length\", # 플롯의 제목을 지정\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\", # 플롯의 부제목을 지정\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\", # 축의 이름을 지정\n    color = \"Species\" # 범례의 제목을 설정\n  )\n```\n\n::: {.cell-output-display}\n![](lab_02_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n::: callout-note\n데이터 시각화에 대한 보다 자세한 내용은 5주차 실습에서 다룬다.\n:::\n\n## 변형하기\n\n변형하기와 관련된 함수들은 대부분 [`dplyr`](https://dplyr.tidyverse.org/) 패키지에 포함되어 있다.\n\n### 데이터 살펴보기\n\n이 실습을 위해 미국 교통통계국(U.S. Bureau of Transportation)이 제공하는 데이터를 사용하는데, 이것은 2013년 한 해 동안 미국 뉴욕시를 출발한 336,776대의 항공기에 대한 정보를 담고 있다. 이 데이터는 [`nycflights13`](https://github.com/tidyverse/nycflights13) 이라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다. 그리고 나서 패키지에 포함되어 있는 `flights`라는 이름의 데이터를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights13)\nglimpse(flights)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 336,776\nColumns: 19\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n`flights` 데이터 내 속성들에 대한 설명을 보고싶다면 `help(flights)` 또는 `?flights`를 입력한 뒤 실행한다.\n:::\n\n### 주요 함수\n\n여기서는 가장 널리 사용되는 6개 함수에 대해서만 개략적으로 다룬다. 그 6개 함수는 `select()`, `filter()`, `arrange()`, `mutate()`, `group_by()`, `summerize()`이다.\n\n#### `select()` 함수\n\n열(변수) 중 일부를 솎아낸다. 즉, 변수의 개수를 줄인다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(flights, year, month, day) # 지정한 열(변수)만 추출\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 3\n    year month   day\n   <int> <int> <int>\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n#### `filter()` 함수\n\n특정 열(변수)에 의거해 조건을 만족하는 행을 솎아낸다. 즉 관측개체의 갯수를 줄인다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(flights, month == 1 & day == 1) # 지정한 행(관측개체)만 추출\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n#### `arrange()` 함수\n\n특정 열(변수)에 의거해 행의 순서를 바꾼다. 내림차순으로 정렬하고 싶다면 `desc(dep_time)`을 넣으면 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(flights, dep_time) # dep_time 오름차순으로 행 정렬\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1    13        1           2249        72      108           2357\n 2  2013     1    31        1           2100       181      124           2225\n 3  2013    11    13        1           2359         2      442            440\n 4  2013    12    16        1           2359         2      447            437\n 5  2013    12    20        1           2359         2      430            440\n 6  2013    12    26        1           2359         2      437            440\n 7  2013    12    30        1           2359         2      441            437\n 8  2013     2    11        1           2100       181      111           2225\n 9  2013     2    24        1           2245        76      121           2354\n10  2013     3     8        1           2355         6      431            440\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n#### `mutate()` 함수\n\n기존의 열(변수)을 변형하여 새로운 열(변수)을 생성한다. 아래에 gain <dbl>, speed <dbl> 변수가 새로 생긴 것을 확인할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(flights,\n    gain = dep_delay - arr_delay, # gain이라는 새로운 열(변수) 생성\n    speed = distance / air_time * 60 # speed라는 새로운 열(변수) 생성\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 21\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>, gain <dbl>, speed <dbl>\n```\n\n\n:::\n:::\n\n\n#### `group_by()` 함수\n\n열(변수)(범주형 변수, categorical variables)에 의거해 전체 행을 그룹으로 분할한다. Groups: month\\[12\\]를 통해 월별로 행이 분할되었음을 알 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_by(flights, month) # 전체 행을 월별로 분할\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n#### `summerize()` 함수\n\n열(변수)의 통계량을 산출하여 새로운 열(변수)에 저장한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE)) # dep_delay의 평균을 delay라는 변수에 저장\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  delay\n  <dbl>\n1  12.6\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## 결측값\n\nR에서 데이터 셋에 결측값이 포함되어 있을 경우 통계량을 계산하면 NA라는 결과를 얻게 된다. 따라서 데이터셋에 결측값이 있는지 확인한 뒤 이를 분석에서 제외하거나 다른 값으로 대체해야 한다. 여기에서는 결측값을 분석에서 제외하는 방법만 다룬다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 결측값을 포함하여 통계량을 계산했을 때\nsummarize(flights, delay = mean(dep_delay))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  delay\n  <dbl>\n1    NA\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# dep_delay변수에 결측값이 몇개 있는지 확인: is.na\nsum(is.na(flights$dep_delay))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8255\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 통계량 계산에서 결측값을 제외: na.rm = TRUE\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  delay\n  <dbl>\n1  12.6\n```\n\n\n:::\n:::\n\n:::\n\n위의 `group_by()` 함수와 결합하면, 그룹별로 열(변수)의 통계량을 산출하여 새로운 열(변수)에 저장할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_day <- group_by(flights, year, month, day) # 전체 행을 연, 월, 일로 분할하여 새로운 변수에 할당\nsummarize(by_day, delay = mean(dep_delay, na.rm = TRUE)) # 일별 delay 계산\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day delay\n   <int> <int> <int> <dbl>\n 1  2013     1     1 11.5 \n 2  2013     1     2 13.9 \n 3  2013     1     3 11.0 \n 4  2013     1     4  8.95\n 5  2013     1     5  5.73\n 6  2013     1     6  7.15\n 7  2013     1     7  5.42\n 8  2013     1     8  2.55\n 9  2013     1     9  2.28\n10  2013     1    10  2.84\n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n\n::: callout-note\n데이터 변형하기에 대한 보다 자세한 내용은 4주차 실습에서 다룬다.\n:::\n\n## 정리하기\n\n정리하기와 관련된 함수들은 대부분 [`tidyr`](https://tidyr.tidyverse.org/) 패키지에 포함되어 있다. 많은 함수가 있지만 가장 중요한 두 개의 함수에만 집중한다.\n\n### 데이터 살펴보기\n\n이 실습에서는 `tidyverse`에 포함되어 있는 매우 단순한 데이터를 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable4a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n\n\n:::\n:::\n\n\n### 주요 함수\n\n#### `pivot_longer()` 함수\n\n`table4a`에서 1999과 2000은 변수명일 수 없다. `year`라는 변수의 속성이어야 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_longer(\n  table4a, \n  cols = c(`1999`, `2000`), # 바꾸고싶은 변수 지정 \n  names_to = \"year\", # 원래 데이터의 변수명들이 들어갈 새로운 변수명 지정\n  values_to = \"cases\" # 원래 데이터의 값들이 들어갈 새로운 변수명 지정\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  country     year   cases\n  <chr>       <chr>  <dbl>\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n```\n\n\n:::\n:::\n\n\n#### `pivot_wider()` 함수\n\n`table2`에서 `type` 변수는 두 개의 변수명을 포함하고 있다. 즉, `cases`와 `population`은 속성값이라기 보다는 변수명이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_wider(\n  table2, \n  names_from = \"type\", # 원래 데이터의 type 값들을 변수로 변환\n  values_from = \"count\" # 원래 데이터의 count 값들을 변수의 값으로 변환\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n\n\n:::\n:::\n\n\n::: callout-note\n데이터 정리하기에 대한 보다 자세한 내용은 3주차 실습에서 다룬다.\n:::\n\n## 불러오기\n\n불러오기와 관련된 함수들은 대부분 [`readr`](https://readr.tidyverse.org/) 패키지에 포함되어 있다. 여러 유형의 파일을 불러오기 위해 여러 함수가 존재하지만, 콤마분리값(comma-separated values, CSV) 형식의 데이터를 불러오는 함수(`read_csv()`)만 실습한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudents <- read_csv(\"https://pos.it/r4ds-students-csv\") # URL에서 가져온 CSV 파일을 students에 할당\nglimpse(students)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 6\nColumns: 5\n$ `Student ID`   <dbl> 1, 2, 3, 4, 5, 6\n$ `Full Name`    <chr> \"Sunil Huffmann\", \"Barclay Lynn\", \"Jayendra Lyne\", \"Leo…\n$ favourite.food <chr> \"Strawberry yoghurt\", \"French fries\", \"N/A\", \"Anchovies…\n$ mealPlan       <chr> \"Lunch only\", \"Lunch only\", \"Breakfast and lunch\", \"Lun…\n$ AGE            <chr> \"4\", \"5\", \"7\", NA, \"five\", \"6\"\n```\n\n\n:::\n:::\n\n\n::: callout-note\n데이터 불러오기에 대한 보다 자세한 내용은 3주차 실습에서 다룬다.\n:::\n\n## 파이프 연산자(pipe operator)\n\n우리는 이전 실습에서 할당 연산자(`<-`)에 대해 배웠다. 오늘 살펴본 다양한 변형의 결과를 다른 데이터 프레임에 담고 싶으면 다음과 같이 할당 연산자를 사용할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_day1 <- filter(flights, month == 1 & day == 1)\nglimpse(flights_day1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 842\nColumns: 19\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n```\n\n\n:::\n:::\n\n\n### 파이프 연산자\n\n-   현재 RStudio의 디폴트는 `%>%`로 설정되어 있다. 이것을 Tools \\> Global Options \\> Code에 가서 'Use native pipe operator, \\|\\> (requires R 4.1+)'를 선택해 주어야 한다. 아래의 @fig-pipe-operator 를 참고하라.\n\n![파이프 연산자(https://r4ds.hadley.nz/data-transform)](https://r4ds.hadley.nz/screenshots/rstudio-pipe-options.png){#fig-pipe-operator}\n\n-   단축키는 **Crtl + Shift + M(Mac은 Commnad + Shift + M)**이다. 다른 건 몰라도 이 단축키만은 반드시 기억해야 한다.\n\nIAH 공항으로 가기 위한 가장 빠른 항공편을 찾기 위한 다음의 코드들을 비교해 보자. 먼저 파이프 연산자를 사용하지 않은 경우이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 중간에 여러 변수를 거쳐야 한다.\nflights1 <- filter(flights, dest == \"IAH\")\nflights2 <- mutate(flights1, speed = distance / air_time * 60)\nflights3 <- select(flights2, year:day, dep_time, carrier, flight, speed)\narrange(flights3, desc(speed))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   <int> <int> <int>    <int> <chr>    <int> <dbl>\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 또는 함수 안에 함수를 집어넣는 과정을 반복해야 한다.\narrange(\n  select(\n    mutate(\n      filter(\n        flights, \n        dest == \"IAH\"\n      ),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   <int> <int> <int>    <int> <chr>    <int> <dbl>\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n```\n\n\n:::\n:::\n\n\n다음은 파이프 연산자를 사용한 경우이다. 동일한 결과를 가져다 주지만 훨신 더 간결하고 직관적이고 이해하기 쉽다. 파이프 연산자의 사용 원리는 이후 실습에서 자세히 배운다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(dest == \"IAH\") |>\n  mutate(speed = distance / air_time * 60) |> \n  select(year:day, dep_time, carrier, flight, speed) |> \n  arrange(desc(speed))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   <int> <int> <int>    <int> <chr>    <int> <dbl>\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n```\n\n\n:::\n:::\n",
    "supporting": [
      "lab_02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}